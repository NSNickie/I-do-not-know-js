# Chapter 2: Illustrating Lexical Scope

本章将通过几个隐喻来说明作用域。这里的目标是思考程序是如何被JS引擎处理的。

## Marbles, and Buckets, and Bubbles... On My!

形象比喻：彩色弹珠与桶

***核心比喻***

- **变量=彩色弹珠**
- **作用域=彩色桶**
- 每个变量的颜色，取决于它声明时所处的作用域（即哪个作用域的桶装了这颗弹珠）

![Colored Scope Bubbles](https://github.com/getify/You-Dont-Know-JS/raw/2nd-ed/scope-closures/images/fig2.png)

**<u>规则总结</u>**

1. **作用域是嵌套的**
   - 全局作用域（红色）包含函数作用域（蓝色），函数作用域再包含块级作用域（绿色）
   - 内层作用域可以访问外层变量，反之不行
2. **变量在编译阶段就被“分桶”了**
   - JS引擎在编译时已经确定那个变量属于哪个作用域
   - 执行时变量查找不会从头搜索，而是直接查找对应的作用域链（提高性能）
3. **变量查找类似“查桶”**
   - 在当前作用域找不到变量，就沿着外层作用域继续查找，直到找到或报错
4. **非变量的属性不是弹珠**
   - 像student.id里的id是对象的属性，不属于作用域查找系统，不是“弹珠”

**<u>*注意事项*</u>**

- 参数虽然写在函数括号中，但我们可以临时把它看做函数作用域的变量
- 若内层作用域出现相同变量名，会“遮蔽”外层（称变量shadowing）
- 所有变量归属是编译时决定的，而不是运行时动态绑定

**<u>作用域就像嵌套的彩色桶，变脸是属于某个桶的彩色弹珠，查找变量就像沿着桶从内往外找相同颜色的弹珠。</u>**
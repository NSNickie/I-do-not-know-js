# Chapter3: The Scope Chain

词法作用域（Lexical Scope），也叫**静态作用域**，是指**一个变量的作用域是在代码定义时就已经确定的，而不是在代码执行时才决定的**。

嵌套在其他作用域中的作用域之间的链接成为作用域链，它决定了可以反问变量的路径。该链是有向的，这意味着查找仅向上/向外的移动。

## Lookup Is (Mostly) Conceptual

在 JavaScript 中，“变量查找（lookup）”指的是运行时为了找到变量的声明位置而在嵌套的作用域链中逐层向上查找的过程。但实际上，这个查找过程**大多数情况下并不真的发生在运行时**。

由于 JS 使用 **词法作用域（Lexical Scope）**，即作用域在代码书写阶段就已经确定，所以在 **编译阶段**，JS 引擎就能分析出每个变量引用来自哪个作用域（可以类比为“给每个变量标颜色”），并把这些信息存储在 AST（抽象语法树）中。这样运行时就不需要再花时间去查找变量的来源，从而大幅优化性能。

但如果变量在当前文件中没有找到声明（比如它是从其他文件来的全局变量），那它的来源就必须等到运行时才能确定。这种变量在编译阶段被视为“无色弹珠”，一旦在运行时找到了对应声明，就“上色”，以后就不需要再次查找。

因此：

- **词法作用域让作用域静态化，从而支持了编译期优化。**
- **变量查找是 JS 引擎在编译时就尽可能解决的。**
- **运行时查找仅用于编译期无法确认的变量，且只需进行一次。**

## Shadowing 遮蔽

在JS中，**变量遮蔽**是指在内层作用域中声明了一个与外层作用域同名的变量，从而使得外层变量在内层作用域中“不可见”。

```javascript
var studentName = "Suzy"; // 全局变量

function printStudent(studentName) {
  studentName = studentName.toUpperCase();
  console.log(studentName);
}

```

上面中：

- 全局变量studentName是RED（1）
- 函数参数studentName是BLUE（2）
- 函数内部访问的都是BLUE（2），全局的RED（1）被遮蔽

JS的变量查找遵循 **词法作用域**规则，即： **从当前作用域向上查找，找到匹配的变量就停止。**

因此：

- **内部作用域声明的变量（shadowing variable）优先**，外层变量（shadowed variable）会被“遮蔽”
- 被遮蔽的变量**在该作用域及其所有内层作用域中都不可见**
- 即使函数内层继续嵌套作用域，也无法再访问全局的同名变量

**编译视角（弹珠隐喻）**：

- 每个变量在编译时会被标上“颜色”，表示它属于哪个作用域
- 被遮蔽的变量（比如全局的 RED(1)）在函数内部是“查不到的”，查找直接命中 BLUE(2)，不再继续向外
- 这有利于 JS 编译器进行优化：变量归属在**编译期**就已确定

**<u>*变量遮蔽 = 内部变量屏蔽了外部同名变量，是词法作用域的自然产物，也是编译优化的基础。*</u>**

